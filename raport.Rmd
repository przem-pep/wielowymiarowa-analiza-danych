---
title: "Analiza ofert mieszkań w Gdańsku"
subtitle: "Wielowymiarowa analiza danych"
author: "Przemysław Peplinski, Wiktor Galewski, Mikołaj Zalewski"
date: "`r Sys.Date()`"
output: pdf_document
toc: true
toc-title: "Spis treści"
fontsize: 12pt

header-includes:
  - \setcounter{secnumdepth}{2}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE)
```

```{r wczytanie-pakietow, include=FALSE}

library(tidyverse)
library(readxl)
library(missForest)
library(corrplot)
library(psych)
library(factoextra)
library(ggcorrplot)
library(ca)
library(FactoMineR)

```

```{r definiowanie-funkcji, include=FALSE}

# Histogram dla podanej zmiennej

histogram <- function(data, x, binwidth = NULL, bins = NULL, title) {
  ggplot(data, aes(x = {{ x }})) +
  geom_histogram(binwidth = binwidth, bins = bins, fill = "firebrick") +
  labs(x = NULL,
       y = NULL,
       title = title) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, size = 16))
}

boxplot <- function(data, x, title) {
  ggplot(data, aes(x = {{ x }})) +
    geom_boxplot(fill = "firebrick", color = "black", outlier.colour = "black", outlier.shape = 16) +
    labs(x = NULL,
         y = NULL,
         title = title) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5, size = 16))
}


```

```{r wczytanie-danych, include=FALSE}

dane <- read_excel("mieszkania.xlsx")

```

# Wstęp

## Autorzy

Autorami są... Wkład w projekt prezentował się następująco...

## Motywacja i cele

Coś tam...

## Opis projektu

Coś tam...

# Opis danych

Dane pochodzą.../Dane zostały zebrane...

```{r przeglad-danych}
glimpse(dane)
```

Opisać zmienne...

Wśród zmiennych niepotrzebnych do analizy można wymienić link, tytuł, opis oraz numer telefonu. Zmienne te zostaną zatem usunięte.

# Czyszczenie danych

## Walidacja

Tak

```{r}
glimpse(dane)
```


```{r walidacja}

```


## Obsługa braków wartości

Kilka zmiennych do usunięcia, dla niektórych trzeba usunąć obserwacje, w innych imputować wg obliczeń.

```{r czyszczenie-danych, include=FALSE}
# usuniecie duplikatow po linku
dane <- distinct(dane, Link, .keep_all = TRUE)

# usuniecie zbednych kolumn
dane <- dane %>%
  select(c(-Link, -Tytuł, -Opis, -`Numer telefonu`, -Ocena, -`Liczba pięter`))

# modyfikacja ogloszenia jako zmienna binarna
dane <- dane %>%
  mutate(`Data modyfikacji` = as.integer(!is.na(`Data modyfikacji`)))

# cena za metr - usuniecie bledow i NA
dane <- dane %>%
  filter(`Cena za metr` >= 1100 & `Cena za metr` <= 63000)

# powierzchnia - usuniecie bledow
dane <- dane %>%
  filter(Powierzchnia >= 14 & Powierzchnia <= 900)

# pietro - usuniecie bledow i NA
dane <- dane %>%
  filter(Piętro >= 0 & Piętro <= 20)

# liczba pokoi - poprawa i wymazanie bledow
dane <- dane %>%
  mutate(`Liczba pokoi` = case_when(
    `Liczba pokoi` %in% c(21, 23) ~ 2,
    `Liczba pokoi` >= 1 & `Liczba pokoi` <= 24 ~ `Liczba pokoi`,
    TRUE ~ NA_real_))

# ogloszeniodawca i rynek - usuniecie NA
dane <- dane %>%
  filter(!is.na(Ogłoszeniodawca) & !is.na(Rynek))

# rok budowy - wymazanie bledow
dane <- dane %>%
  mutate(`Rok budowy` = if_else(between(`Rok budowy`, 1780, 2028), 
                                `Rok budowy`, NA_real_))

# rodzaj budynku - pozostale jako NA
dane <- dane %>%
  mutate(`Rodzaj budynku` = na_if(`Rodzaj budynku`, "Pozostałe"))

# usuniecie obserwacji, gdzie zarowno rok budowy, jak i rodzaj budynku sa NA
dane <- dane %>%
  filter(!(is.na(`Rok budowy`) & is.na(`Rodzaj budynku`)))

# modyfikacja typow niektorych zmiennych
dane <- dane %>%
  mutate(`Data dodania` = as.numeric(as.Date(`Data dodania`))) %>%
  mutate(across(c(Dzielnica, `Rodzaj budynku`, Portal), as.factor)) %>%
  mutate(Rynek = as.integer(Rynek == "Pierwotny")) %>%
  mutate(`Rok budowy` = as.integer(`Rok budowy`)) %>%
  mutate(Ogłoszeniodawca = as.integer(Ogłoszeniodawca == "Agencja"))

# imputacja brakow danych (liczba pokoi, rok budowy, rodzaj budynku)
imputacje <- missForest(as.data.frame(dane), verbose = TRUE)
dane <- imputacje$ximp
```

## Obsługa obserwacji odstających

Jako tako zostawiamy

# Analiza eksploracyjna

## Statystyki opisowe

```{r statystyki-opisowe}
summary(dane)
```


## Analiza rozkładów

Histogramy zmiennych numerycznych, wykresy kolumnowe zmiennych kategorycznych

```{r histogramy, fig.align='center', fig.width=6, fig.height=4}

# Histogram pięter

histogram(
  data = dane,
  x = Piętro,
  binwidth = 1,
  title = "Rozkład pięter mieszkań"
)

# Histogram cen mieszkań

histogram(
  data = dane,
  x = Cena,
  bins = 100,
  title = "Rozkład cen mieszkań w zł"
)

# Histogram ceny za metr

histogram(
  data = dane,
  x = `Cena za metr`,
  bins = 50,
  title = "Rozkład ceny za metr kwadratowy mieszkań w zł/m^2"
)

# Histogram powierzchni mieszkań

histogram(
  data = dane,
  x = Powierzchnia,
  bins = 50,
  title = "Rozkład powierzchni mieszkań w m^2"
)

# Histogram liczby pokoi

histogram(
  data = dane,
  x = `Liczba pokoi`,
  binwidth = 1,
  title = "Rozkład liczby pokoi"
)
```

## Analiza korelacji

Macierz korelacji

``` {r macierz-korelacji, fig.align='center', fig.width=6, fig.height=4}

korelacje <- dane %>%
  select(where(is.numeric)) %>%
  cor()

corrplot(korelacje,
         method = "color",
         addCoef.col = "black",
         tl.col = "black",
         tl.srt = 45,
         number.cex = 0.75,
         tl.cex = 0.75)

```

## Analiza braków danych

Krótkie podsumowanie braków danych (wykres słupkowy?)

```{r zliczenie-brakow-danych, fig.align='center', fig.width=6, fig.height=4}
braki_danych <- colSums(is.na(dane)) / nrow(dane)
ggplot(mapping = aes(x = names(braki_danych), y = braki_danych)) +
  geom_col(fill = "firebrick") +
  scale_y_continuous(labels = scales::percent) +
  labs(title = "Udział braków danych wg zmiennej",
       x = NULL,
       y = NULL) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 90))

```

## Analiza obserwacji odstających

Wykresy pudełkowe zmiennych 

``` {r box-ploty, fig.align='center', fig.width=6, fig.height=4}
# wykres pudełkowy pięter

boxplot(
  data = dane,
  x = Piętro,
  title = "Wykres pudełkowy pięter mieszkań"
)


# Wykres pudełkowy cen mieszkań

boxplot(
  data = dane,
  x = Cena,
  title = "Wykres pudełkowy cen mieszkań w zł"
)

# Wykres pudełkowy ceny za metr

boxplot(
  data = dane,
  x = `Cena za metr`,
  title = "Wykres pudełkowy ceny za metr kwadratowy mieszkań w zł/m^2"
)

# Wykres pudełkowy powierzchni mieszkań

boxplot(
  data = dane,
  x = Powierzchnia,
  title = "Wykres pudełkowy powierzchni mieszkań w m^2"
)

# Wykres pudełkowy liczby pokoi

boxplot(
  data = dane,
  x = `Liczba pokoi`,
  title = "Wykres pudełkowy liczby pokoi"
)




```

# Obróbka zmiennych

## Normalizacja zmiennych numerycznych

```{r normalizacja}

dane_std <- dane %>%
  select(Cena, Powierzchnia, `Liczba pokoi`, Piętro, `Rok budowy`) %>%
  sapply(FUN = scale) %>%
  as.data.frame() %>%
  as_tibble()


```

# Analiza wielowymiarowa

## Analiza głównych składowych (PCA)

W zbiorze danych tylko pięć ze zmiennych można wykorzystać do przeprowadzenia analizy głównych składowych. Ponieważ PCA wykorzystuje kowariancję, którą oblicza się za pomocą wariancji, wśród zmiennych uwzględnionych w analizie mogą znaleźć się tylko zmienne, dla których istnieje logiczny sens obliczenia różnicy pomiędzy jedną a drugą wartością. W tym zbiorze danych występuje 5 takich zmiennych: cena, powierzchnia, liczba pokoi, piętro oraz rok budowy. Cena za metr kwadratowy zostaje pominięta ze względu na redundancję informacji ze zmiennymi ceny oraz powierzchni. Podane 5 zmiennych zostało wykorzystane do analizy głównych składowych.

``` {r pca-setup}

cor_pca <- cor(dane_std)

cortest.bartlett(cor_pca)

```

Za pomocą testu Bartletta sprawdzamy czy sensowne jest wykonywanie PCA. Hipoteza zerowa tego testu mówi, że macierz korelacji jest macierzą jednostkową, czyli zmienne nie są skorelowane, a w tym przypadku nie ma sensu wykonywać PCA. Hipoteza alternatywna z kolei mówi, że macierz korelacji nie jest macierzą jednostkową, więc zmienne są skorelowane, a zatem istnieje sens wykonywania PCA.

Na podstawie wykonanego testu Bartletta widać, że wartość p wynosi ok. 7,5e-31, a zatem odrzucamy hipotezę zerową. Z tego względu w kolejnym kroku wykonujemy PCA.


```{r pca-1, fig.align='center', fig.width=6, fig.height=4}

pca <- prcomp(dane_std, center = FALSE, scale. = FALSE)

fviz_screeplot(pca, geom = "line", addlabels = TRUE)

```

```{r pca-2}

get_eig(pca)

```
Korzystając z kryterium Keisera można określić, że mieszkania można określić za pomocą pierwszych dwóch głównych składowych, ponieważ dla nich wartości własne są większe od 1. Taki sam wniosek można wyciągnąć na podstawie oceny wykresu osypiska, gdyż po drugim wymiarze zmiana wariancji jest znacznie mniejsza.

## Analiza skupień (clustering)

Drugą wykonaną analizą jest analiza skupień. Została tutaj wykorzystana metoda k-średnich. Analiza została przeprowadzona dla tych samych zmiennych, co PCA.

Ze względu na rozmiar zbioru danych, niemożliwe jest stworzenie wykresów za pomocą funkcji fviz_nbclust, nawet dla metody łokciowej WSS, ze względu na ich złożoność obliczeniową związaną z wielokrotnym klastrowaniem i zapisywaniem tych wyników. Z tego względu, jedyną alternatywą jest manualne zastosowanie metody k-średnich, przy zapisywaniu tylko aktualnego obiektu kmeans oraz sumy kwadratów z każdej liczby klastrów, a następnie przedstawienie sum kwadratów wewnątrz klastrów na wykresie, co wykonano poniżej.


```{r }

# Manualnie przeprowadzona metoda łokciowa WSS

set.seed(123)

wss <- numeric(10)

for (k in 1:10) {
  km <- kmeans(dane_std, centers = k, nstart = 25)
  wss[k] <- km$tot.withinss
}

plot(1:10, wss, type = "b",
     xlab = "Number of clusters (k)",
     ylab = "Total within-cluster Sum of Squares")


```
Wykres nie daje bardzo konkluzywnej odpowiedzi na pytanie ile klastrów użyć, natomiast na podstawie oceny wykresu można powiedzieć, że 3 klastry powinny być dobrą opcją. Analiza została zatem przeprowadzona dla trzech klastrów.



```{r }

km3 <- kmeans(dane_std, centers = 3, nstart = 25)

dane_grupy <- dane %>%
  select(Cena, Powierzchnia, `Liczba pokoi`, Piętro, `Rok budowy`) %>%
  mutate(Grupa = as.factor(km3$cluster))


```





# Wizualizacja metod

## Wizualizacje PCA

```{r wizualizacje-pca-1, fig.align='center', fig.width=6, fig.height=4}

pcaVars <- get_pca_var(pca)

ggcorrplot(pcaVars$coord[, 1:2],
           colors = c("blue","white","blue"),
           tl.cex = 9,
           lab = TRUE,
           lab_size = 3
           )


```

Mieszkania można zatem opisać za pomocą dwóch składowych głównych. Pierwsza z nich dotyczy parametrów samego mieszkania, które dotyczą rozmiaru oraz wartości rynkowej nieruchomości. Obserwacje z niskimi wartościami tej składowej to małe, tańsze mieszkania, np. kawalerki, natomiast wyższe wartości mogą oznaczać duże, wielopokojowe nieruchomości. Druga składowa główna dotyczy właściwości samego budynku, w którym znajduje się to mieszkanie. Niskie wartości tej składowej oznaczają niskie, stare budynki, a wyższe wartości wskazują na nowsze budynki w wysokiej zabudowie.

```{r wizualizacje-pca-2, fig.align='center', fig.width=6, fig.height=4}

fviz_pca_biplot(pca,
                repel = TRUE,
                col.var = "blue",
                col.ind = "orange",
                label = "var",
                labelsize = 4)


```

Wykres biplot pozwala na wyciągnięcie dwóch istotnych wniosków.

Po pierwsze, potwierdza się wniosek wyciągnięty z macierzy korelacji o sile i kierunku wpływu zmiennych na poszczególne główne składowe.

Po drugie, przedstawienie obserwacji za pomocą punktów wskazuje, że występuje mała ilość silnie odstających obserwacji w pierwszym z wymiarów. Mogą to być wielopokojowe apartamenty przeznaczone na wynajem pojedynczych pokoi, a być może i hostele lub hotele. W drugim wymiarze nie ma tak silnie odstających obserwacji, lecz pojawiają się stare nieruchomości o niskiej zabudowie.


## Wizualizacje analizy skupień

```{r wizualizacje-clustering}

fviz_cluster(km3, data = dane_std, geom = "point")

ggscatter(x = "Rok budowy", y = "Cena", color = "Grupa", data = dane_grupy)


```



# Wnioski



